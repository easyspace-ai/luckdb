package server

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/easyspace-ai/luckdb/server/internal/mcp/protocol"
	"github.com/easyspace-ai/luckdb/server/internal/mcp/tools"
	"github.com/easyspace-ai/luckdb/server/internal/mcp/resources"
	"github.com/easyspace-ai/luckdb/server/internal/mcp/prompts"
	"github.com/gin-gonic/gin"
)

// MCPServer MCP 服务器
type MCPServer struct {
	router          *protocol.Router
	handler         protocol.Handler
	config          *Config
	logger          *log.Logger
	httpServer      *http.Server
	toolService     tools.ToolService
	resourceService resources.ResourceService
	promptService   prompts.PromptService
}

// Config MCP 服务器配置
type Config struct {
	Host         string        `json:"host"`
	Port         int           `json:"port"`
	ReadTimeout  time.Duration `json:"read_timeout"`
	WriteTimeout time.Duration `json:"write_timeout"`
	IdleTimeout  time.Duration `json:"idle_timeout"`
	EnableCORS   bool          `json:"enable_cors"`
	EnableDebug  bool          `json:"enable_debug"`
}

// DefaultConfig 默认配置
func DefaultConfig() *Config {
	return &Config{
		Host:         "0.0.0.0",
		Port:         8081,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
		IdleTimeout:  120 * time.Second,
		EnableCORS:   true,
		EnableDebug:  false,
	}
}

// NewMCPServer 创建新的 MCP 服务器
func NewMCPServer(config *Config, logger *log.Logger) *MCPServer {
	if config == nil {
		config = DefaultConfig()
	}

	if logger == nil {
		logger = log.New(log.Writer(), "[MCP] ", log.LstdFlags|log.Lshortfile)
	}

	router := protocol.NewRouter()

	// 创建中间件处理器
	middlewareHandler := protocol.NewMiddlewareHandler(router,
		protocol.ContextMiddleware(),
		protocol.LoggingMiddleware(logger),
		protocol.ValidationMiddleware(protocol.NewRequestValidator()),
	)

	// 包装错误处理器
	handler := protocol.NewErrorHandler(middlewareHandler)

	// 初始化服务
	toolService := tools.NewBaseToolService()
	resourceService := resources.NewBaseResourceService()
	promptService := prompts.NewBasePromptService()

	server := &MCPServer{
		router:          router,
		handler:         handler,
		config:          config,
		logger:          logger,
		toolService:     toolService,
		resourceService: resourceService,
		promptService:   promptService,
	}

	// 注册路由
	server.registerRoutes()

	return server
}

// wrapHandler 包装处理器以适配不同的方法签名
func (s *MCPServer) wrapHandler(handler func(ctx context.Context, req *MCPRequest) (*MCPResponse, error)) protocol.MethodHandler {
	return func(ctx context.Context, params interface{}) (interface{}, error) {
		// 创建一个模拟的 MCPRequest
		req := &MCPRequest{
			JSONRPC: "2.0",
			Method:  "", // 这个方法名会在路由时设置
			Params:  params,
		}
		
		resp, err := handler(ctx, req)
		if err != nil {
			return nil, err
		}
		
		return resp.Result, nil
	}
}

// registerRoutes 注册路由
func (s *MCPServer) registerRoutes() {
	// 注册工具相关路由
	s.router.Register("tools/list", s.wrapHandler(s.handleToolsList))
	s.router.Register("tools/call", s.wrapHandler(s.handleToolsCall))
	
	// 注册资源相关路由
	s.router.Register("resources/list", s.wrapHandler(s.handleResourcesList))
	s.router.Register("resources/read", s.wrapHandler(s.handleResourcesRead))
	
	// 注册提示相关路由
	s.router.Register("prompts/list", s.wrapHandler(s.handlePromptsList))
	s.router.Register("prompts/get", s.wrapHandler(s.handlePromptsGet))
}

// RegisterHandlers 注册处理器
func (s *MCPServer) RegisterHandlers() {
	// 初始化处理器
	s.router.Register("initialize", s.handleInitialize)

	// 工具处理器
	s.router.Register("tools/list", s.handleToolsList)
	s.router.Register("tools/call", s.handleToolsCall)

	// 资源处理器
	s.router.Register("resources/list", s.handleResourcesList)
	s.router.Register("resources/read", s.handleResourcesRead)

	// 提示处理器
	s.router.Register("prompts/list", s.handlePromptsList)
	s.router.Register("prompts/get", s.handlePromptsGet)
}

// Start 启动服务器
func (s *MCPServer) Start() error {
	s.RegisterHandlers()

	// 设置 Gin 模式
	if s.config.EnableDebug {
		gin.SetMode(gin.DebugMode)
	} else {
		gin.SetMode(gin.ReleaseMode)
	}

	// 创建 Gin 引擎
	engine := gin.New()

	// 添加中间件
	engine.Use(gin.Logger())
	engine.Use(gin.Recovery())

	if s.config.EnableCORS {
		engine.Use(s.corsMiddleware())
	}

	// 注册路由
	s.registerRoutes(engine)

	// 创建 HTTP 服务器
	s.httpServer = &http.Server{
		Addr:         fmt.Sprintf("%s:%d", s.config.Host, s.config.Port),
		Handler:      engine,
		ReadTimeout:  s.config.ReadTimeout,
		WriteTimeout: s.config.WriteTimeout,
		IdleTimeout:  s.config.IdleTimeout,
	}

	s.logger.Printf("Starting MCP Server on %s", s.httpServer.Addr)

	// 启动服务器
	return s.httpServer.ListenAndServe()
}

// Stop 停止服务器
func (s *MCPServer) Stop(ctx context.Context) error {
	if s.httpServer == nil {
		return nil
	}

	s.logger.Println("Stopping MCP Server...")
	return s.httpServer.Shutdown(ctx)
}

// registerRoutes 注册路由
func (s *MCPServer) registerRoutes(engine *gin.Engine) {
	// 健康检查
	engine.GET("/health", s.healthCheck)
	engine.GET("/ready", s.readinessCheck)

	// MCP 协议端点
	api := engine.Group("/mcp")
	{
		api.POST("/", s.handleMCPRequest)
		api.GET("/capabilities", s.getCapabilities)
	}

	// 管理端点
	admin := engine.Group("/admin")
	{
		admin.GET("/methods", s.getRegisteredMethods)
		admin.GET("/status", s.getStatus)
	}
}

// handleMCPRequest 处理 MCP 请求
func (s *MCPServer) handleMCPRequest(c *gin.Context) {
	var req protocol.MCPRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		s.logger.Printf("Failed to parse MCP request: %v", err)
		c.JSON(http.StatusBadRequest, protocol.NewMCPErrorResponse(nil, protocol.ErrorCodeParseError, "Invalid JSON", nil))
		return
	}

	// 处理请求
	ctx := c.Request.Context()
	resp, err := s.handler.Handle(ctx, &req)
	if err != nil {
		s.logger.Printf("Failed to handle MCP request: %v", err)
		c.JSON(http.StatusInternalServerError, protocol.NewMCPErrorResponse(req.ID, protocol.ErrorCodeInternalError, "Internal server error", nil))
		return
	}

	// 返回响应
	c.JSON(http.StatusOK, resp)
}

// healthCheck 健康检查
func (s *MCPServer) healthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":    "healthy",
		"timestamp": time.Now().Unix(),
		"service":   "mcp-server",
	})
}

// readinessCheck 就绪检查
func (s *MCPServer) readinessCheck(c *gin.Context) {
	// 这里可以添加更多的就绪检查逻辑
	// 比如检查数据库连接、Redis 连接等

	c.JSON(http.StatusOK, gin.H{
		"status":    "ready",
		"timestamp": time.Now().Unix(),
		"service":   "mcp-server",
	})
}

// getCapabilities 获取服务器能力
func (s *MCPServer) getCapabilities(c *gin.Context) {
	capabilities := protocol.ServerCapabilities{
		Tools: &protocol.ToolsCapability{
			ListChanged: true,
		},
		Resources: &protocol.ResourcesCapability{
			Subscribe:   false,
			ListChanged: true,
		},
		Prompts: &protocol.PromptsCapability{
			ListChanged: true,
		},
		Logging: &protocol.LoggingCapability{},
	}

	c.JSON(http.StatusOK, capabilities)
}

// getRegisteredMethods 获取已注册的方法
func (s *MCPServer) getRegisteredMethods(c *gin.Context) {
	methods := s.router.GetRegisteredMethods()
	c.JSON(http.StatusOK, gin.H{
		"methods": methods,
		"count":   len(methods),
	})
}

// getStatus 获取服务器状态
func (s *MCPServer) getStatus(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"status":  "running",
		"version": protocol.MCPVersion,
		"uptime":  time.Since(time.Now()).String(), // 这里应该记录启动时间
		"methods": len(s.router.GetRegisteredMethods()),
		"config":  s.config,
	})
}

// corsMiddleware CORS 中间件
func (s *MCPServer) corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "*")
		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-MCP-API-Key")
		c.Header("Access-Control-Allow-Credentials", "true")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}

		c.Next()
	}
}

// 处理器方法实现

// handleInitialize 处理初始化请求
func (s *MCPServer) handleInitialize(ctx context.Context, params interface{}) (interface{}, error) {
	// 解析初始化请求
	initReq, ok := params.(*protocol.InitializeRequest)
	if !ok {
		// 尝试从 map 转换
		if paramsMap, ok := params.(map[string]interface{}); ok {
			initReq = &protocol.InitializeRequest{}
			if data, err := json.Marshal(paramsMap); err == nil {
				if err := json.Unmarshal(data, initReq); err != nil {
					return nil, protocol.NewInvalidParamsError("Invalid initialize request format")
				}
			}
		} else {
			return nil, protocol.NewInvalidParamsError("Invalid initialize request format")
		}
	}

	// 验证协议版本
	if initReq.ProtocolVersion != protocol.MCPVersion {
		return nil, protocol.NewInvalidProtocolVersionError(initReq.ProtocolVersion)
	}

	// 返回初始化响应
	response := &protocol.InitializeResponse{
		ProtocolVersion: protocol.MCPVersion,
		Capabilities: protocol.ServerCapabilities{
			Tools: &protocol.ToolsCapability{
				ListChanged: true,
			},
			Resources: &protocol.ResourcesCapability{
				Subscribe:   false,
				ListChanged: true,
			},
			Prompts: &protocol.PromptsCapability{
				ListChanged: true,
			},
			Logging: &protocol.LoggingCapability{},
		},
		ServerInfo: protocol.ServerInfo{
			Name:    "LuckDB MCP Server",
			Version: "1.0.0",
		},
	}

	return response, nil
}

// ==================== 新的处理器方法 ====================

// handleToolsList 处理工具列表请求
func (s *MCPServer) handleToolsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	tools, err := s.toolService.GetTools(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}

	response := &protocol.ToolsListResponse{
		Tools: tools,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleToolsCall 处理工具调用请求
func (s *MCPServer) handleToolsCall(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ToolCallRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid tool call parameters: %w", err)
	}

	result, err := s.toolService.CallTool(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to call tool: %w", err)
	}

	response := &protocol.ToolCallResponse{
		Content: result.Content,
		IsError: result.IsError,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesList 处理资源列表请求
func (s *MCPServer) handleResourcesList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	resources, err := s.resourceService.GetResources(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get resources: %w", err)
	}

	response := &protocol.ResourcesListResponse{
		Resources: resources,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesRead 处理资源读取请求
func (s *MCPServer) handleResourcesRead(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ResourceReadRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid resource read parameters: %w", err)
	}

	content, err := s.resourceService.ReadResource(ctx, params.URI)
	if err != nil {
		return nil, fmt.Errorf("failed to read resource: %w", err)
	}

	response := &protocol.ResourceReadResponse{
		Contents: []protocol.MCPResourceContent{*content},
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsList 处理提示列表请求
func (s *MCPServer) handlePromptsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	prompts, err := s.promptService.GetPrompts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompts: %w", err)
	}

	response := &protocol.PromptsListResponse{
		Prompts: prompts,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsGet 处理提示获取请求
func (s *MCPServer) handlePromptsGet(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.PromptGetRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid prompt get parameters: %w", err)
	}

	result, err := s.promptService.GetPrompt(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt: %w", err)
	}

	response := &protocol.PromptGetResponse{
		Description: result.Description,
		Messages:    result.Messages,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleToolsList 处理工具列表请求
func (s *MCPServer) handleToolsList(ctx context.Context, params interface{}) (interface{}, error) {
	// 返回可用工具列表
	tools := []protocol.Tool{
		{
			Name:        "query_records",
			Description: "查询指定表的记录数据",
			InputSchema: map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"space_id": map[string]interface{}{
						"type":        "string",
						"description": "空间ID",
					},
					"table_id": map[string]interface{}{
						"type":        "string",
						"description": "表ID",
					},
				},
				"required": []string{"space_id", "table_id"},
			},
		},
		{
			Name:        "get_table_schema",
			Description: "获取指定表的结构信息",
			InputSchema: map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"space_id": map[string]interface{}{
						"type":        "string",
						"description": "空间ID",
					},
					"table_id": map[string]interface{}{
						"type":        "string",
						"description": "表ID",
					},
				},
				"required": []string{"space_id", "table_id"},
			},
		},
	}

	return map[string]interface{}{
		"tools": tools,
	}, nil
}

// handleToolsCall 处理工具调用请求
func (s *MCPServer) handleToolsCall(ctx context.Context, params interface{}) (interface{}, error) {
	// 解析工具调用请求
	callReq, ok := params.(*protocol.ToolCallRequest)
	if !ok {
		return nil, protocol.NewInvalidParamsError("Invalid tool call request format")
	}

	// 根据工具名称调用相应的处理器
	switch callReq.Name {
	case "query_records":
		return s.handleQueryRecords(ctx, callReq.Arguments)
	case "get_table_schema":
		return s.handleGetTableSchema(ctx, callReq.Arguments)
	default:
		return nil, protocol.NewToolNotFoundError(callReq.Name)
	}
}

// handleResourcesList 处理资源列表请求
func (s *MCPServer) handleResourcesList(ctx context.Context, params interface{}) (interface{}, error) {
	// 返回可用资源列表
	resources := []protocol.Resource{
		{
			URI:         "table://{space_id}/{table_id}/schema",
			Name:        "表结构",
			Description: "获取指定表的结构信息",
			MimeType:    "application/json",
		},
		{
			URI:         "data://{space_id}/{table_id}/records",
			Name:        "记录数据",
			Description: "获取指定表的记录数据",
			MimeType:    "application/json",
		},
	}

	return map[string]interface{}{
		"resources": resources,
	}, nil
}

// handleResourcesRead 处理资源读取请求
func (s *MCPServer) handleResourcesRead(ctx context.Context, params interface{}) (interface{}, error) {
	// 解析资源读取请求
	readReq, ok := params.(*protocol.ResourceReadRequest)
	if !ok {
		return nil, protocol.NewInvalidParamsError("Invalid resource read request format")
	}

	// 根据 URI 处理资源读取
	// 这里暂时返回示例数据
	response := &protocol.ResourceReadResponse{
		Contents: []protocol.ResourceContent{
			{
				URI:      readReq.URI,
				MimeType: "application/json",
				Text:     `{"message": "Resource content placeholder"}`,
			},
		},
	}

	return response, nil
}

// ==================== 新的处理器方法 ====================

// handleToolsList 处理工具列表请求
func (s *MCPServer) handleToolsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	tools, err := s.toolService.GetTools(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}

	response := &protocol.ToolsListResponse{
		Tools: tools,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleToolsCall 处理工具调用请求
func (s *MCPServer) handleToolsCall(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ToolCallRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid tool call parameters: %w", err)
	}

	result, err := s.toolService.CallTool(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to call tool: %w", err)
	}

	response := &protocol.ToolCallResponse{
		Content: result.Content,
		IsError: result.IsError,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesList 处理资源列表请求
func (s *MCPServer) handleResourcesList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	resources, err := s.resourceService.GetResources(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get resources: %w", err)
	}

	response := &protocol.ResourcesListResponse{
		Resources: resources,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesRead 处理资源读取请求
func (s *MCPServer) handleResourcesRead(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ResourceReadRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid resource read parameters: %w", err)
	}

	content, err := s.resourceService.ReadResource(ctx, params.URI)
	if err != nil {
		return nil, fmt.Errorf("failed to read resource: %w", err)
	}

	response := &protocol.ResourceReadResponse{
		Contents: []protocol.MCPResourceContent{*content},
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsList 处理提示列表请求
func (s *MCPServer) handlePromptsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	prompts, err := s.promptService.GetPrompts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompts: %w", err)
	}

	response := &protocol.PromptsListResponse{
		Prompts: prompts,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsGet 处理提示获取请求
func (s *MCPServer) handlePromptsGet(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.PromptGetRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid prompt get parameters: %w", err)
	}

	result, err := s.promptService.GetPrompt(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt: %w", err)
	}

	response := &protocol.PromptGetResponse{
		Description: result.Description,
		Messages:    result.Messages,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsList 处理提示列表请求
func (s *MCPServer) handlePromptsList(ctx context.Context, params interface{}) (interface{}, error) {
	// 返回可用提示列表
	prompts := []protocol.Prompt{
		{
			Name:        "analyze_data",
			Description: "数据分析提示模板",
			Arguments: []protocol.PromptArgument{
				{
					Name:        "data_description",
					Description: "数据描述",
					Required:    true,
				},
			},
		},
	}

	return map[string]interface{}{
		"prompts": prompts,
	}, nil
}

// handlePromptsGet 处理提示获取请求
func (s *MCPServer) handlePromptsGet(ctx context.Context, params interface{}) (interface{}, error) {
	// 解析提示获取请求
	getReq, ok := params.(*protocol.PromptGetRequest)
	if !ok {
		return nil, protocol.NewInvalidParamsError("Invalid prompt get request format")
	}

	// 根据提示名称返回相应的提示
	switch getReq.Name {
	case "analyze_data":
		response := &protocol.PromptGetResponse{
			Description: "数据分析提示模板",
			Messages: []protocol.PromptMessage{
				{
					Role: "user",
					Content: protocol.PromptMessageContent{
						Type: "text",
						Text: "请分析以下数据并生成洞察报告",
					},
				},
			},
		}
		return response, nil
	default:
		return nil, protocol.NewPromptNotFoundError(getReq.Name)
	}
}

// 工具处理器实现

// handleQueryRecords 处理查询记录请求
func (s *MCPServer) handleQueryRecords(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	// 验证参数
	spaceID, ok := args["space_id"].(string)
	if !ok {
		return nil, protocol.NewValidationFailedError("space_id", "Space ID is required and must be a string")
	}

	tableID, ok := args["table_id"].(string)
	if !ok {
		return nil, protocol.NewValidationFailedError("table_id", "Table ID is required and must be a string")
	}

	// 这里应该调用实际的业务逻辑
	// 暂时返回示例数据
	response := &protocol.ToolCallResponse{
		Content: []protocol.ToolCallContent{
			{
				Type: "text",
				Text: fmt.Sprintf("查询空间 %s 中表 %s 的记录数据", spaceID, tableID),
			},
		},
		IsError: false,
	}

	return response, nil
}

// ==================== 新的处理器方法 ====================

// handleToolsList 处理工具列表请求
func (s *MCPServer) handleToolsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	tools, err := s.toolService.GetTools(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}

	response := &protocol.ToolsListResponse{
		Tools: tools,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleToolsCall 处理工具调用请求
func (s *MCPServer) handleToolsCall(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ToolCallRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid tool call parameters: %w", err)
	}

	result, err := s.toolService.CallTool(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to call tool: %w", err)
	}

	response := &protocol.ToolCallResponse{
		Content: result.Content,
		IsError: result.IsError,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesList 处理资源列表请求
func (s *MCPServer) handleResourcesList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	resources, err := s.resourceService.GetResources(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get resources: %w", err)
	}

	response := &protocol.ResourcesListResponse{
		Resources: resources,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesRead 处理资源读取请求
func (s *MCPServer) handleResourcesRead(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ResourceReadRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid resource read parameters: %w", err)
	}

	content, err := s.resourceService.ReadResource(ctx, params.URI)
	if err != nil {
		return nil, fmt.Errorf("failed to read resource: %w", err)
	}

	response := &protocol.ResourceReadResponse{
		Contents: []protocol.MCPResourceContent{*content},
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsList 处理提示列表请求
func (s *MCPServer) handlePromptsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	prompts, err := s.promptService.GetPrompts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompts: %w", err)
	}

	response := &protocol.PromptsListResponse{
		Prompts: prompts,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsGet 处理提示获取请求
func (s *MCPServer) handlePromptsGet(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.PromptGetRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid prompt get parameters: %w", err)
	}

	result, err := s.promptService.GetPrompt(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt: %w", err)
	}

	response := &protocol.PromptGetResponse{
		Description: result.Description,
		Messages:    result.Messages,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleGetTableSchema 处理获取表结构请求
func (s *MCPServer) handleGetTableSchema(ctx context.Context, args map[string]interface{}) (interface{}, error) {
	// 验证参数
	spaceID, ok := args["space_id"].(string)
	if !ok {
		return nil, protocol.NewValidationFailedError("space_id", "Space ID is required and must be a string")
	}

	tableID, ok := args["table_id"].(string)
	if !ok {
		return nil, protocol.NewValidationFailedError("table_id", "Table ID is required and must be a string")
	}

	// 这里应该调用实际的业务逻辑
	// 暂时返回示例数据
	response := &protocol.ToolCallResponse{
		Content: []protocol.ToolCallContent{
			{
				Type: "text",
				Text: fmt.Sprintf("获取空间 %s 中表 %s 的结构信息", spaceID, tableID),
			},
		},
		IsError: false,
	}

	return response, nil
}

// ==================== 新的处理器方法 ====================

// handleToolsList 处理工具列表请求
func (s *MCPServer) handleToolsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	tools, err := s.toolService.GetTools(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get tools: %w", err)
	}

	response := &protocol.ToolsListResponse{
		Tools: tools,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleToolsCall 处理工具调用请求
func (s *MCPServer) handleToolsCall(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ToolCallRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid tool call parameters: %w", err)
	}

	result, err := s.toolService.CallTool(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to call tool: %w", err)
	}

	response := &protocol.ToolCallResponse{
		Content: result.Content,
		IsError: result.IsError,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesList 处理资源列表请求
func (s *MCPServer) handleResourcesList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	resources, err := s.resourceService.GetResources(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get resources: %w", err)
	}

	response := &protocol.ResourcesListResponse{
		Resources: resources,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handleResourcesRead 处理资源读取请求
func (s *MCPServer) handleResourcesRead(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.ResourceReadRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid resource read parameters: %w", err)
	}

	content, err := s.resourceService.ReadResource(ctx, params.URI)
	if err != nil {
		return nil, fmt.Errorf("failed to read resource: %w", err)
	}

	response := &protocol.ResourceReadResponse{
		Contents: []protocol.MCPResourceContent{*content},
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsList 处理提示列表请求
func (s *MCPServer) handlePromptsList(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	prompts, err := s.promptService.GetPrompts(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompts: %w", err)
	}

	response := &protocol.PromptsListResponse{
		Prompts: prompts,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}

// handlePromptsGet 处理提示获取请求
func (s *MCPServer) handlePromptsGet(ctx context.Context, req *protocol.MCPRequest) (*protocol.MCPResponse, error) {
	var params protocol.PromptGetRequest
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return nil, fmt.Errorf("invalid prompt get parameters: %w", err)
	}

	result, err := s.promptService.GetPrompt(ctx, params.Name, params.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt: %w", err)
	}

	response := &protocol.PromptGetResponse{
		Description: result.Description,
		Messages:    result.Messages,
	}

	return &protocol.MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  response,
	}, nil
}
