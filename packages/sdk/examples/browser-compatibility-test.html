<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LuckDB SDK æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
      }
      .status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
      }
      .status.success {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
      .status.info {
        background-color: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
      }
      .log {
        background-color: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
        padding: 15px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 12px;
        max-height: 400px;
        overflow-y: auto;
        white-space: pre-wrap;
      }
      .controls {
        margin: 20px 0;
      }
      button {
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #6c757d;
        cursor: not-allowed;
      }
      .event-item {
        background-color: #f8f9fa;
        border-left: 4px solid #007bff;
        padding: 10px;
        margin: 5px 0;
        border-radius: 0 4px 4px 0;
      }
      .event-time {
        font-size: 11px;
        color: #6c757d;
      }
      .event-type {
        font-weight: bold;
        color: #007bff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸš€ LuckDB SDK æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</h1>
        <p>æµ‹è¯• SDK åœ¨æµè§ˆå™¨ç¯å¢ƒä¸­çš„ WebSocket åŠŸèƒ½</p>
      </div>

      <div id="status" class="status info">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»"å¼€å§‹æµ‹è¯•"æŒ‰é’®å¼€å§‹</div>

      <div class="controls">
        <button id="startTest" onclick="startTest()">å¼€å§‹æµ‹è¯•</button>
        <button id="stopTest" onclick="stopTest()" disabled>åœæ­¢æµ‹è¯•</button>
        <button id="clearLog" onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
      </div>

      <h3>ğŸ“Š æµ‹è¯•ç»Ÿè®¡</h3>
      <div id="stats" class="status info">æ€»äº‹ä»¶æ•°: 0 | è¿æ¥çŠ¶æ€: æœªè¿æ¥ | è¿è¡Œæ—¶é—´: 0s</div>

      <h3>ğŸ“ å®æ—¶äº‹ä»¶</h3>
      <div id="events" style="max-height: 300px; overflow-y: auto">
        <div class="status info">ç­‰å¾…äº‹ä»¶...</div>
      </div>

      <h3>ğŸ“‹ è¯¦ç»†æ—¥å¿—</h3>
      <div id="log" class="log">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>
    </div>

    <!-- ä½¿ç”¨ CDN åŠ è½½ SDK -->
    <script type="module">
      // æ¨¡æ‹Ÿ SDK å¯¼å…¥ï¼ˆå®é™…ä½¿ç”¨æ—¶éœ€è¦ä» npm åŒ…å¯¼å…¥ï¼‰
      // import { LuckDB } from '@easyspace/luckdb-sdk';

      // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„ SDK ç±»
      class MockLuckDB {
        constructor(config) {
          this.config = config;
          this.ws = null;
          this.isConnected = false;
          this.eventListeners = {
            recordChange: [],
            collaboration: [],
            presenceUpdate: [],
            cursorUpdate: [],
            notification: [],
          };
        }

        async login(credentials) {
          this.log('æ­£åœ¨ç™»å½•...', 'info');
          // æ¨¡æ‹Ÿç™»å½•
          await new Promise((resolve) => setTimeout(resolve, 1000));
          this.log('ç™»å½•æˆåŠŸ', 'success');
          return {
            user: { id: 'browser_user', email: credentials.email },
            accessToken: 'mock_token_' + Date.now(),
            refreshToken: 'mock_refresh_' + Date.now(),
          };
        }

        connectWebSocket() {
          this.log('æ­£åœ¨è¿æ¥ WebSocket...', 'info');

          // æ£€æŸ¥æµè§ˆå™¨ WebSocket æ”¯æŒ
          if (!window.WebSocket) {
            throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ WebSocket');
          }

          // åˆ›å»º WebSocket è¿æ¥
          const wsUrl = 'ws://localhost:8080/ws?token=mock_token&user_id=browser_user';
          this.ws = new WebSocket(wsUrl);

          this.ws.onopen = () => {
            this.isConnected = true;
            this.log('WebSocket è¿æ¥æˆåŠŸ', 'success');
            this.updateStatus('WebSocket è¿æ¥æˆåŠŸ', 'success');
            this.updateStats();
          };

          this.ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              this.log(`æ”¶åˆ° WebSocket æ¶ˆæ¯: ${JSON.stringify(message, null, 2)}`, 'info');
              this.addEvent('WebSocket æ¶ˆæ¯', message);
              this.handleWebSocketMessage(message);
            } catch (e) {
              this.log(`è§£æ WebSocket æ¶ˆæ¯å¤±è´¥: ${e.message}`, 'error');
            }
          };

          this.ws.onclose = () => {
            this.isConnected = false;
            this.log('WebSocket è¿æ¥å…³é—­', 'warning');
            this.updateStatus('WebSocket è¿æ¥å…³é—­', 'error');
            this.updateStats();
          };

          this.ws.onerror = (error) => {
            this.log(`WebSocket é”™è¯¯: ${error}`, 'error');
            this.updateStatus('WebSocket è¿æ¥é”™è¯¯', 'error');
          };
        }

        handleWebSocketMessage(message) {
          // æ ¹æ®æ¶ˆæ¯ç±»å‹è§¦å‘ç›¸åº”çš„äº‹ä»¶ç›‘å¬å™¨
          if (message.type === 'op') {
            this.eventListeners.recordChange.forEach((callback) => {
              callback(message);
            });
          }
        }

        onRecordChange(callback) {
          this.eventListeners.recordChange.push(callback);
          this.log('å·²æ³¨å†Œè®°å½•å˜æ›´ç›‘å¬å™¨', 'info');
        }

        onCollaboration(callback) {
          this.eventListeners.collaboration.push(callback);
          this.log('å·²æ³¨å†Œåä½œäº‹ä»¶ç›‘å¬å™¨', 'info');
        }

        onPresenceUpdate(callback) {
          this.eventListeners.presenceUpdate.push(callback);
          this.log('å·²æ³¨å†Œåœ¨çº¿çŠ¶æ€ç›‘å¬å™¨', 'info');
        }

        onCursorUpdate(callback) {
          this.eventListeners.cursorUpdate.push(callback);
          this.log('å·²æ³¨å†Œå…‰æ ‡æ›´æ–°ç›‘å¬å™¨', 'info');
        }

        onNotification(callback) {
          this.eventListeners.notification.push(callback);
          this.log('å·²æ³¨å†Œé€šçŸ¥ç›‘å¬å™¨', 'info');
        }

        subscribeToTable(tableId) {
          if (!this.isConnected) {
            throw new Error('WebSocket æœªè¿æ¥');
          }

          const message = {
            type: 'subscribe',
            collection: 'table',
            document: tableId,
            id: 'sub_' + Date.now() + '_table.' + tableId,
          };

          this.ws.send(JSON.stringify(message));
          this.log(`å·²è®¢é˜…è¡¨æ ¼: ${tableId}`, 'success');
        }

        disconnectWebSocket() {
          if (this.ws) {
            this.ws.close();
            this.ws = null;
            this.isConnected = false;
            this.log('WebSocket è¿æ¥å·²æ–­å¼€', 'info');
          }
        }

        getWebSocketState() {
          if (!this.ws) return 'disconnected';
          switch (this.ws.readyState) {
            case WebSocket.CONNECTING:
              return 'connecting';
            case WebSocket.OPEN:
              return 'connected';
            case WebSocket.CLOSING:
              return 'closing';
            case WebSocket.CLOSED:
              return 'disconnected';
            default:
              return 'unknown';
          }
        }

        log(message, type = 'info') {
          const timestamp = new Date().toLocaleTimeString();
          const logElement = document.getElementById('log');
          const logEntry = `[${timestamp}] ${message}\n`;
          logElement.textContent += logEntry;
          logElement.scrollTop = logElement.scrollHeight;
        }

        addEvent(type, data) {
          const eventsContainer = document.getElementById('events');
          const eventElement = document.createElement('div');
          eventElement.className = 'event-item';
          eventElement.innerHTML = `
                    <div class="event-time">${new Date().toLocaleTimeString()}</div>
                    <div class="event-type">${type}</div>
                    <div>${JSON.stringify(data, null, 2)}</div>
                `;
          eventsContainer.insertBefore(eventElement, eventsContainer.firstChild);

          // é™åˆ¶äº‹ä»¶æ•°é‡
          while (eventsContainer.children.length > 20) {
            eventsContainer.removeChild(eventsContainer.lastChild);
          }
        }

        updateStatus(message, type) {
          const statusElement = document.getElementById('status');
          statusElement.textContent = message;
          statusElement.className = `status ${type}`;
        }

        updateStats() {
          const statsElement = document.getElementById('stats');
          const eventCount = document.getElementById('events').children.length - 1; // å‡å»"ç­‰å¾…äº‹ä»¶..."æç¤º
          const state = this.getWebSocketState();
          const runtime = Math.floor((Date.now() - this.startTime) / 1000);
          statsElement.textContent = `æ€»äº‹ä»¶æ•°: ${eventCount} | è¿æ¥çŠ¶æ€: ${state} | è¿è¡Œæ—¶é—´: ${runtime}s`;
        }
      }

      // å…¨å±€å˜é‡
      let sdk = null;
      let testInterval = null;
      let eventCount = 0;

      // æµ‹è¯•å‡½æ•°
      window.startTest = async function () {
        try {
          document.getElementById('startTest').disabled = true;
          document.getElementById('stopTest').disabled = false;

          // åˆ›å»º SDK å®ä¾‹
          sdk = new MockLuckDB({
            baseURL: 'http://localhost:8080',
            debug: true,
          });
          sdk.startTime = Date.now();

          // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
          sdk.onRecordChange((message) => {
            eventCount++;
            sdk.log(`è®°å½•å˜æ›´äº‹ä»¶ #${eventCount}: ${JSON.stringify(message)}`, 'success');
          });

          sdk.onCollaboration((message) => {
            eventCount++;
            sdk.log(`åä½œäº‹ä»¶ #${eventCount}: ${JSON.stringify(message)}`, 'info');
          });

          sdk.onPresenceUpdate((message) => {
            eventCount++;
            sdk.log(`åœ¨çº¿çŠ¶æ€æ›´æ–° #${eventCount}: ${JSON.stringify(message)}`, 'info');
          });

          sdk.onCursorUpdate((message) => {
            eventCount++;
            sdk.log(`å…‰æ ‡æ›´æ–° #${eventCount}: ${JSON.stringify(message)}`, 'info');
          });

          sdk.onNotification((message) => {
            eventCount++;
            sdk.log(`é€šçŸ¥äº‹ä»¶ #${eventCount}: ${JSON.stringify(message)}`, 'info');
          });

          // ç™»å½•
          await sdk.login({ email: 'browser@test.com', password: 'test123' });

          // è¿æ¥ WebSocket
          sdk.connectWebSocket();

          // ç­‰å¾…è¿æ¥å»ºç«‹
          await new Promise((resolve) => setTimeout(resolve, 2000));

          // è®¢é˜…è¡¨æ ¼
          sdk.subscribeToTable('tbl_test');

          // å¼€å§‹å®šæœŸæ›´æ–°ç»Ÿè®¡
          testInterval = setInterval(() => {
            if (sdk) {
              sdk.updateStats();
            }
          }, 1000);

          sdk.log('æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•å·²å¯åŠ¨', 'success');
        } catch (error) {
          sdk.log(`æµ‹è¯•å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
          document.getElementById('startTest').disabled = false;
          document.getElementById('stopTest').disabled = true;
        }
      };

      window.stopTest = function () {
        if (sdk) {
          sdk.disconnectWebSocket();
          sdk = null;
        }

        if (testInterval) {
          clearInterval(testInterval);
          testInterval = null;
        }

        document.getElementById('startTest').disabled = false;
        document.getElementById('stopTest').disabled = true;

        const statusElement = document.getElementById('status');
        statusElement.textContent = 'æµ‹è¯•å·²åœæ­¢';
        statusElement.className = 'status info';
      };

      window.clearLog = function () {
        document.getElementById('log').textContent = '';
        document.getElementById('events').innerHTML = '<div class="status info">ç­‰å¾…äº‹ä»¶...</div>';
        eventCount = 0;
      };

      // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
      document.addEventListener('DOMContentLoaded', function () {
        const logElement = document.getElementById('log');
        logElement.textContent = 'é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å¼€å§‹æµ‹è¯•...\n';

        // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
        const compatibility = {
          webSocket: !!window.WebSocket,
          json: !!window.JSON,
          promises: !!window.Promise,
          fetch: !!window.fetch,
        };

        let compatibilityStatus = 'æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥:\n';
        Object.entries(compatibility).forEach(([feature, supported]) => {
          compatibilityStatus += `  ${feature}: ${supported ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}\n`;
        });

        logElement.textContent += compatibilityStatus;
      });
    </script>
  </body>
</html>
